/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

// Remove Widgets in CodeMirror Editor
const clearWidges = (cm) => {
  var lastLine = cm.lastLine();
  for (let i = 0; i <= lastLine; i++) {
    // Get the current Line
    const line = cm.lineInfo(i);
    // Clear the image widgets if exists
    if (line.widgets) {
      for (const wid of line.widgets) {
        if (wid.className === 'test-inline-math') {
          wid.clear();
        }
      }
    }
  }
};


const getFileCmBelongsTo = (cm, workspace) => {
  var _a;
  let leafs = workspace.getLeavesOfType("markdown");
  for (let i = 0; i < leafs.length; i++) {
    if (leafs[i].view instanceof obsidian.MarkdownView && ((_a = leafs[i].view.sourceMode) === null || _a === void 0 ? void 0 : _a.cmEditor) == cm) {
      return leafs[i].view.file;
    }
  }
  return null;
};

class InlineMathEval extends obsidian.Plugin {
  constructor() {
    super(...arguments);
    // Line Edit Changes
    this.codemirrorLineChanges = (cm, change) => {
      this.check_lines(cm, change.from.line, change.from.line + change.text.length - 1);
    };
    // Only Triggered during initial Load
    this.handleInitialLoad = (cm) => {
      var lastLine = cm.lastLine();
      var file = getFileCmBelongsTo(cm, this.app.workspace);
      for (let i = 0; i < lastLine; i++) {
        this.check_line(cm, i, file);
      }
    };
    // Check Single Line
    this.check_line = (cm, line_number, targetFile) => {

      // const regex = /{{([^}}]+)}}/;
      const varr = /(\$[A-z]+) /;
      const math = /(.*)::=/;
      const line = cm.lineInfo(line_number);
      if (line === null)
        return;

      const maths = line.text.match(math);

      if (line.widgets) {
        for (const wid of line.widgets) {
          if (wid.className === 'test-inline-math') {
            wid.clear();
          }
        }
      }

      if (maths) {

        // var w = document.createElement("span")

        var result;
        try {
          result = eval(maths[1])
        } catch (e) {
          result = "error"
        }

        result = "= " + result.toString()

        cm.replaceRange(result, {
          line: line_number,
          ch: line.text.indexOf("::=")
        }, {
          line: line_number
        })


        // w.innerHTML = result
        // cm.addLineWidget(line_number, w, {
        //   className: 'test-inline-math'
        // });
      }
    };
    // Check All Lines Function
    this.check_lines = (cm, from, to) => {
      // Last Used Line Number in Code Mirror
      var file = getFileCmBelongsTo(cm, this.app.workspace);
      for (let i = from; i <= to; i++) {
        this.check_line(cm, i);
      }
    };
  }
  onload() {
    // Register event for each change
    this.registerCodeMirror((cm) => {
      cm.on("change", this.codemirrorLineChanges);
      this.handleInitialLoad(cm);
    });
  }
  onunload() {
    this.app.workspace.iterateCodeMirrors((cm) => {
      cm.off("change", this.codemirrorLineChanges);
      clearWidges(cm);
    });
    new obsidian.Notice('Image in Editor Plugin is unloaded');
  }
}

module.exports = InlineMathEval;